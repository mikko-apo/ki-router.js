{
  "name": "zhain",
  "version": "0.0.10",
  "devDependencies": {
    "mocha": "1.8.x",
    "chai": "1.5.x",
    "jquery-browser": "1.9.x",
    "mocha-phantomjs": "2.0.x"
  },
  "homepage": "https://github.com/mtkopone/zhain",
  "scripts": {
    "test": "./node_modules/.bin/mocha-phantomjs ./test.html"
  },
  "engines": {
    "node": "*"
  },
  "main": "/zhain",
  "repository": {
    "type": "git",
    "url": "https://github.com/mtkopone/zhain.git"
  },
  "readme": "# Zhain\n\nFor - you know - zhaining things... Runs in the browser and in node.js.\n\n[![Build Status](https://secure.travis-ci.org/mtkopone/zhain.png?branch=master)](https://travis-ci.org/mtkopone/zhain)\n\n[Download](https://raw.github.com/mtkopone/zhain/master/zhain.js) or `npm install zhain`\n\n# Example\n\n```javascript\nzhain()\n  .do(function() { console.log('Hello') })\n  .do(function() { console.log('world') })\n  .run()\n```\n\n(Yeah, that's a really complicated way to say 'Hello world'.)\n\n## Usage\n\n`.do` takes a function. \n\nIf that function takes parameters, the function is assumed to be asynchronous and the last parameter is expected to be the callback. \n\nFunctions without parameters are assumed to be synchronous.\n\n`.sync` is an alias for `.do` which can take a function with parameters and is still synchronous.\n\nLike so:\n\n```javascript\nzhain()\n  .do(function() { console.log('Pow!') })              // sync\n  .do(function(done) { setTimeout(done, 250) })        // async\n  .run()\n```\n\n## Passing state\n\nReturn values from synchronous functions are passed on to the next method in the chain:\n\n```javascript\nzhain()\n  .do(function() { return 'Pow!' })\n  .sync(function(pow) { console.log('Got: ' + pow) })\n  .run()\n```\n\nThe callback provided to asynchronous functions can be invoked with arguments. The first argument is reserved for errors (you know, node.js style), the next arguments are passed on to the next method in the chain:\n\n```javascript\nzhain()\n  .do(function(done) { done(null, 'Pow!', 'Wop!') })\n  .do(function(pow, wop, done) { assert.equal(pow, 'Pow!'); done() })\n  .run()\n```\n\n## `.run` and `.end` and errors\n\n`.run` runs the chain. It can optionally be passed a function which is invoked once the chain is complete. \n\n`.end` returns a function that when invoked will run the chain. It's useful for creating re-runnable chains and using zhain in e.g. mocha tests:\n\n```javascript\nvar sayPow = zhain().do(function() { console.log('Pow'); }).end()\nsayPow(); sayPow()\n\nit('tests things', zhain()\n  .do(function() { assert.equal(1,1) })\n  .end())\n```\n\nIf no errors occur, the ending function will receive the output of the last method in the chain.\n\n```javascript\nzhain()\n  .do(function() { return 1 })\n  .run(function(err, result) { console.log('Haz result: '+result) })\n\n```\n\nIf a method in the chain throws an exception or invokes the callback with an error (1st argument, node.js style), the rest of the chain is bypassed and the ending function is invoked with the received error:\n\nSynchronously:\n\n```javascript\nzhain()\n  .do(function() { throw 'Fail...' })\n  .do(function() { console.log('I should never be called.') })\n  .run(function(err) {\n    console.log(\"D'oh: \" + err)\n  })\n```\n\nAsynchronously:\n\n```javascript\nzhain()\n  .do(function(done) { done('Fail...') })\n  .do(function() { console.log('I should never be called.') })\n  .run(function(err) {\n    console.log(\"D'oh: \" + err)\n  })\n```\n\n## `this` and that\n\nInside `.do`, `this` is a per-run zhain instance. Passing state between functions can therefore also be done like this:\n\n```javascript\nzhain()\n  .do(function() { this.pow = 'pow' })\n  .do(function() { assert.equal(this.pow, 'pow') })\n  .run()\n```\n\nWhen the function returned by `.end` is invoked with a `this`, it's bound to `this.context` within functions of the chain.\n\nExample - output the test title and set a [test specific timeout](http://visionmedia.github.com/mocha/#test-specific-timeouts) in mocha:\n\n```javascript\nit('does things', zhain()\n  .do(function() { console.log('Running: ' + this.context.test.title) })\n  .do(function() { this.context.timeout('2s') })\n    // moar test\n  .end())\n```\n\n## Extending the Zhain\n\nTo make real use of zhain, extend it with something more domain-relevant, like so:\n\n```javascript\nZhain.prototype.waitForAjax = function() {\n  return this.do(function(done) {\n    if (!$.active) return done()\n    $('body').one('ajaxStop', function() {\n      done()\n    })\n  })\n}\n``` \n\nIn node.js, the prototype is at `require('zhain').prototype`\n\n## Real'ish World Example\n\nRecipe for writing concise and readable client-side mocha tests:\n\n1. Extend the zhain prototype with domain-specific helper methods\n2. Write your test, e.g.:\n\n```javascript\nit('updates person name', zhain()\n  .setupUI().waitForAjax()\n  .openTab('Person')\n  .assertText($('#person span.first-name'), 'Joe')\n  .click($('#person button.edit'))\n  .assertVal($('#person input.first-name'), 'Joe')  \n  .enterVal($('#person input.first-name'), 'Jack')\n  .click($('#person button.save'))\n  .waitForAjax()  \n  .assertText($('#person span.first-name'), 'Jack')\n  .end())\n```\n\n<div style=\"margin-top:100px;\">Enjoy,</div>\n\n\n\n\n\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "zhain@0.0.10",
  "description": "For - you know - zhaining things... Runs in the browser and in node.js.",
  "dist": {
    "shasum": "91074b7395bd3b3ab9faac974d778e1c14b94bac",
    "tarball": "http://registry.npmjs.org/zhain/-/zhain-0.0.10.tgz"
  },
  "_from": "zhain@0.0.10",
  "_npmVersion": "1.2.18",
  "_npmUser": {
    "name": "mtkopone",
    "email": "koponen@iki.fi"
  },
  "maintainers": [
    {
      "name": "mtkopone",
      "email": "koponen@iki.fi"
    }
  ],
  "directories": {},
  "_shasum": "91074b7395bd3b3ab9faac974d778e1c14b94bac",
  "_resolved": "https://registry.npmjs.org/zhain/-/zhain-0.0.10.tgz"
}
